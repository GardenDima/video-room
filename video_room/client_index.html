<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>–í–∏–¥–µ–æ–∫–æ–º–Ω–∞—Ç–∞ ‚Äî Single HTML</title>
  <style>
    :root{--bg:#0f1724;--card:#0b1220;--accent:#06b6d4;--muted:#94a3b8;--surface:#0b1220}
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;color:#e6eef6;background:linear-gradient(180deg,#061022 0%, #071428 100%)}
    .app{max-width:1200px;margin:18px auto;padding:16px;display:grid;grid-template-columns:1fr 320px;gap:16px}
    .card{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:8px;box-shadow:0 6px 18px rgba(2,6,23,0.6)}
    header h1{margin:0;font-size:18px}

    /* Top controls */
    .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px}
    input[type=text],select{background:transparent;border:1px solid rgba(255,255,255,0.06);padding:8px;border-radius:6px;color:inherit}
    button{background:var(--accent);color:#022;border:none;padding:8px 10px;border-radius:6px;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--muted)}

    /* Grid for videos */
    .stage{display:grid;grid-template-columns:repeat(auto-fill,minmax(220px,1fr));gap:8px}
    .video-tile{position:relative;background:#000;border-radius:6px;overflow:hidden;min-height:140px}
    video{width:100%;height:100%;object-fit:cover;background:#000}
    .tile-label{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,0.5);padding:6px 8px;border-radius:6px;font-size:13px;display:flex;gap:8px;align-items:center}
    .speaking{box-shadow:0 0 0 3px rgba(6,182,212,0.12);border-radius:6px}

    /* Right column */
    .sidebar{display:flex;flex-direction:column;gap:12px}
    .participants{max-height:280px;overflow:auto}
    .participant{display:flex;align-items:center;gap:8px;padding:8px;border-radius:6px}
    .avatar{width:40px;height:40px;border-radius:8px;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#0b1220,#071028);border:1px solid rgba(255,255,255,0.03)}
    .name{font-size:14px}
    .small{font-size:12px;color:var(--muted)}

    /* Chat */
    .chat{display:flex;flex-direction:column;height:260px}
    .messages{flex:1;overflow:auto;padding:8px;border-radius:6px;background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))}
    .message{margin-bottom:8px}
    .chat-input{display:flex;gap:8px;margin-top:8px}
    .linkbox{background:rgba(255,255,255,0.02);padding:8px;border-radius:6px;font-size:13px}

    footer{margin-top:10px;color:var(--muted);font-size:13px}
    @media (max-width:980px){.app{grid-template-columns:1fr}}
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <header class="controls">
        <div style="flex:1">
          <h1>–í–∏–¥–µ–æ–∫–æ–º–Ω–∞—Ç–∞ ‚Äî –æ–¥–Ω–æ—Ñ–∞–π–ª–æ–≤—ã–π –¥–µ–º–æ-–∫–ª–∏–µ–Ω—Ç</h1>
          <div class="small">–ü—Ä–æ—Ç–æ—Ç–∏–ø –Ω–∞ HTML/CSS/JS –¥–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è (—Ç—Ä–µ–±—É–µ—Ç—Å—è signalling server Socket.IO).</div>
        </div>
      </header>

      <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px">
        <input id="myName" type="text" placeholder="–í–∞—à–µ –∏–º—è" style="width:200px" />
        <input id="roomId" type="text" placeholder="ID –∫–æ–º–Ω–∞—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: party-1)" style="width:220px" />
        <button id="createBtn">–°–æ–∑–¥–∞—Ç—å</button>
        <button id="joinBtn" class="ghost">–í–æ–π—Ç–∏</button>
        <button id="copyLink" class="ghost">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
      </div>

      <div style="display:flex;gap:8px;align-items:center;margin-bottom:12px">
        <label class="small">–ö–∞–º–µ—Ä–∞</label>
        <select id="videoSelect"></select>
        <label class="small">–ú–∏–∫—Ä–æ—Ñ–æ–Ω</label>
        <select id="audioSelect"></select>
        <button id="btnToggleCam" class="ghost">–ö–∞–º–µ—Ä–∞ –≤—ã–∫–ª</button>
        <button id="btnToggleMic" class="ghost">–ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª</button>
      </div>

      <div class="stage card" id="stage" style="padding:10px">
        <!-- video tiles added here -->
      </div>

      <div style="margin-top:12px" class="card">
        <div style="display:flex;justify-content:space-between;align-items:center">
          <div class="small">–°—Ç–∞—Ç—É—Å: <span id="status">–Ω–µ –≤ –∫–æ–º–Ω–∞—Ç–µ</span></div>
          <div class="small">–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–º—É —Å–µ—Ä–≤–µ—Ä—É: <span id="sockStatus">‚Äî</span></div>
        </div>
      </div>

      <footer>
        –ò—Å–ø–æ–ª—å–∑—É–µ—Ç WebRTC mesh-–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∏ Socket.IO –∫–∞–∫ —Å–∏–≥–Ω–∞–ª—å–Ω—ã–π —Å–µ—Ä–≤–µ—Ä. –î–ª—è –ø—Ä–æ–¥–∞–∫—à–Ω–∞ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ SFU (mediasoup/jitsi) –¥–ª—è >6 —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤.
      </footer>
    </div>

    <aside class="sidebar">
      <div class="card">
        <h3>–£—á–∞—Å—Ç–Ω–∏–∫–∏ <span id="count">(0)</span></h3>
        <div class="participants" id="participants"></div>
      </div>

      <div class="card chat">
        <h3>–ß–∞—Ç</h3>
        <div class="messages" id="messages"></div>
        <div class="chat-input">
          <input id="chatInput" type="text" placeholder="–°–æ–æ–±—â–µ–Ω–∏–µ..." />
          <button id="sendBtn">–û—Ç–ø—Ä–∞–≤–∏—Ç—å</button>
        </div>
      </div>

      <div class="card">
        <h4>–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ</h4>
        <div class="linkbox" id="inviteBox">–°—Å—ã–ª–∫–∞ –ø–æ—è–≤–∏—Ç—Å—è –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è/–≤—Ö–æ–¥–∞</div>
      </div>
    </aside>
  </div>

  <!-- Socket.IO client (CDN) -->
  <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>
  <script>
    // =================== –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ===================
    // –£–∫–∞–∂–∏—Ç–µ –∞–¥—Ä–µ—Å signalling server'a (—Ç–æ—Ç –∂–µ API, —á—Ç–æ –≤ Node/Express + Socket.IO –∏–∑ –ø–µ—Ä–≤–æ–≥–æ —à–∞–±–ª–æ–Ω–∞)
    const SIGNALING = (() => location.hostname === 'localhost' ? 'http://localhost:4000' : location.origin)();

    // =================== –°–æ—Å—Ç–æ—è–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è ===================
    let socket = null;
    const pcs = {}; // RTCPeerConnection –ø–æ remoteId
    const remoteStreams = {}; // stream by id
    let localStream = null;
    let joinedRoom = null;
    let profile = { name: '', avatar: 'üôÇ' };

    // UI —ç–ª–µ–º–µ–Ω—Ç—ã
    const el = id => document.getElementById(id);
    const stage = el('stage');
    const participantsBox = el('participants');
    const messagesBox = el('messages');
    const inviteBox = el('inviteBox');

    // Helpers
    function log(...args){ console.log(...args); }
    function showStatus(t){ el('status').textContent = t; }
    function setSocketStatus(s){ el('sockStatus').textContent = s; }

    // =================== Signaling ===================
    function ensureSocket(){
      if (socket) return socket;
      socket = io(SIGNALING, { autoConnect: false });

      socket.on('connect', ()=> setSocketStatus('connected'));
      socket.on('disconnect', ()=> setSocketStatus('disconnected'));
      socket.on('connect_error', (e)=> setSocketStatus('error'));

      socket.on('participants-update', list => onParticipants(list));
      socket.on('signal', async ({ from, data }) => handleSignal(from, data));
      socket.on('chat-message', m => addMessage(m));
      socket.on('chat-history', arr => { arr.forEach(m=>addMessage({ message: m })); });

      return socket;
    }

    // =================== Room flow ===================
    async function createRoom(){
      const name = el('myName').value.trim();
      const room = el('roomId').value.trim();
      if (!name) return alert('–£–∫–∞–∂–∏—Ç–µ –∏–º—è');
      if (!room || room.length < 3) return alert('ID –∫–æ–º–Ω–∞—Ç—ã –º–∏–Ω–∏–º—É–º 3 —Å–∏–º–≤–æ–ª–∞');
      profile.name = name;
      joinedRoom = room;
      ensureSocket();
      socket.connect();
      socket.emit('create-room', { roomId: room, profile }, res => {
        if (res?.error) return alert(res.error);
        showStatus('—Å–æ–∑–¥–∞–ª/–≤–æ—à—ë–ª –≤ –∫–æ–º–Ω–∞—Ç—É');
        inviteBox.textContent = location.origin + location.pathname + '?room=' + room;
        if (res.participants) setupPeersForExisting(res.participants);
      });
    }

    async function joinRoom(){
      const name = el('myName').value.trim();
      const room = el('roomId').value.trim();
      if (!name) return alert('–£–∫–∞–∂–∏—Ç–µ –∏–º—è');
      if (!room) return alert('–£–∫–∞–∂–∏—Ç–µ ID –∫–æ–º–Ω–∞—Ç—ã');
      profile.name = name;
      joinedRoom = room;
      ensureSocket();
      socket.connect();
      socket.emit('join-room', { roomId: room, profile }, async (res) => {
        if (res?.error) return alert(res.error);
        showStatus('–≤ –∫–æ–º–Ω–∞—Ç–µ');
        inviteBox.textContent = location.origin + location.pathname + '?room=' + room;
        await setupPeersForExisting(res.participants || []);
      });
    }

    function setupPeersForExisting(participants){
      const others = participants.filter(p => p.socketId !== socket.id);
      for (const p of others) createPeerConnection(p.socketId, true);
    }

    // =================== WebRTC helpers ===================
    async function getLocalMedia(){
      if (localStream) return localStream;
      const vid = el('videoSelect').value || undefined;
      const aud = el('audioSelect').value || undefined;
      const constraints = { audio: aud ? { deviceId: { exact: aud } } : true, video: vid ? { deviceId: { exact: vid }, width: { ideal: 640 } } : { width: { ideal: 640 } } };
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      attachLocalTile(localStream);
      try{
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const src = audioCtx.createMediaStreamSource(localStream);
        const analyser = audioCtx.createAnalyser(); analyser.fftSize = 256; src.connect(analyser);
        const data = new Uint8Array(analyser.frequencyBinCount);
        (function loop(){ analyser.getByteFrequencyData(data); const sum = data.reduce((a,b)=>a+b,0); const avg = sum/data.length; socket && socket.emit('status-update',{ roomId: joinedRoom, status: { speaking: avg>18 } }); requestAnimationFrame(loop); })();
      }catch(e){/*ignore*/}
      return localStream;
    }

    async function createPeerConnection(remoteId, isOfferer){
      if (pcs[remoteId]) return pcs[remoteId];
      const pc = new RTCPeerConnection({ iceServers:[{urls:'stun:stun.l.google.com:19302'}] });
      pcs[remoteId] = pc;

      if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

      pc.onicecandidate = e => { if (e.candidate) socket.emit('signal', { to: remoteId, data: { type:'ice', candidate: e.candidate } }); };

      pc.ontrack = e => {
        remoteStreams[remoteId] = e.streams[0];
        attachRemoteTile(remoteId, remoteStreams[remoteId]);
      };

      if (isOfferer){
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit('signal', { to: remoteId, data: { type:'offer', sdp: offer } });
      }

      return pc;
    }

    async function handleSignal(from, data){
      if (!pcs[from] && data.type==='offer') await createPeerConnection(from, false);
      const pc = pcs[from];
      if (data.type === 'offer'){
        await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit('signal', { to: from, data: { type:'answer', sdp: answer } });
      } else if (data.type === 'answer'){
        await pc.setRemoteDescription(new RTCSessionDescription(data.sdp));
      } else if (data.type === 'ice'){
        try{ await pc.addIceCandidate(new RTCIceCandidate(data.candidate)); }catch(e){console.warn('ICE add failed',e)}
      }
    }

    // =================== UI: tiles & participants ===================
    function attachLocalTile(stream){
      const id = 'tile-local';
      let elTile = document.getElementById(id);
      if (elTile) elTile.remove();
      elTile = document.createElement('div'); elTile.className = 'video-tile tile-local speaking'; elTile.id = id;
      const v = document.createElement('video'); v.autoplay=true; v.playsInline=true; v.muted=true; v.srcObject = stream; elTile.appendChild(v);
      const label = document.createElement('div'); label.className='tile-label'; label.textContent = profile.name || '–í—ã'; elTile.appendChild(label);
      stage.prepend(elTile);
    }

    function attachRemoteTile(id, stream){
      const tiledId = 'tile-'+id;
      let tile = document.getElementById(tiledId);
      if (tile) tile.remove();
      tile = document.createElement('div'); tile.className='video-tile'; tile.id = tiledId;
      const v = document.createElement('video'); v.autoplay=true; v.playsInline=true; v.srcObject = stream; tile.appendChild(v);
      const label = document.createElement('div'); label.className='tile-label'; label.textContent = id; tile.appendChild(label);
      stage.appendChild(tile);
    }

    function clearTiles(){ stage.querySelectorAll('.video-tile').forEach(n=>n.remove()); }

    function onParticipants(list){
      participantsBox.innerHTML = '';
      el('count').textContent = '('+ (list.length) +')';
      for (const p of list){
        const row = document.createElement('div'); row.className='participant';
        const a = document.createElement('div'); a.className='avatar'; a.textContent = p.avatar || 'üôÇ';
        const info = document.createElement('div');
        const nm = document.createElement('div'); nm.className='name'; nm.textContent = p.name || 'Guest';
        const small = document.createElement('div'); small.className='small'; small.textContent = p.speaking ? '–ì–æ–≤–æ—Ä–∏—Ç' : (p.socketId === socket.id ? '–í—ã' : '–ü–æ–¥–∫–ª—é—á—ë–Ω');
        info.appendChild(nm); info.appendChild(small);
        row.appendChild(a); row.appendChild(info);
        participantsBox.appendChild(row);
      }
    }

    // =================== Chat ===================
    function addMessage(m){
      const div = document.createElement('div'); div.className='message';
      const who = (m.message && m.message.from) || m.from || m.from || 'server';
      const text = (m.message && m.message.text) || m.message && m.message.text || m.message || '';
      // handle format where server emits { message: msg } and also direct msg objects
      const content = m.message ? m.message : m;
      const name = content.from || content.name || 'anon';
      const txt = content.text || content.text || (content.message && content.message.text) || content;
      div.innerHTML = '<strong>'+escapeHtml(name)+'</strong>: '+escapeHtml(txt);
      messagesBox.appendChild(div);
      messagesBox.scrollTop = messagesBox.scrollHeight;
    }

    function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // =================== Device list & switching ===================
    async function populateDevices(){
      const devices = await navigator.mediaDevices.enumerateDevices();
      const vids = devices.filter(d=>d.kind==='videoinput');
      const auds = devices.filter(d=>d.kind==='audioinput');
      const selV = el('videoSelect'); const selA = el('audioSelect');
      selV.innerHTML=''; selA.innerHTML='';
      vids.forEach(v=>{ const o=document.createElement('option'); o.value=v.deviceId; o.textContent=v.label||('–ö–∞–º–µ—Ä–∞ '+(selV.length+1)); selV.appendChild(o)});
      auds.forEach(a=>{ const o=document.createElement('option'); o.value=a.deviceId; o.textContent=a.label||('–ú–∏–∫—Ä–æ—Ñ–æ–Ω '+(selA.length+1)); selA.appendChild(o)});
    }

    async function switchDevices(){
      if (localStream) { localStream.getTracks().forEach(t=>t.stop()); localStream=null; }
      await getLocalMedia();
      for (const id in pcs){
        const pc = pcs[id];
        const senders = pc.getSenders();
        const tracks = localStream.getTracks();
        for (const t of tracks){
          const kind = t.kind;
          const sender = senders.find(s => s.track && s.track.kind === kind);
          if (sender) sender.replaceTrack(t);
          else pc.addTrack(t, localStream);
        }
      }
    }

    // =================== Toggle mic/cam ===================
    function toggleMic(){ if (!localStream) return; const ats = localStream.getAudioTracks(); if (!ats.length) return; ats.forEach(t=>t.enabled = !t.enabled); el('btnToggleMic').textContent = ats[0].enabled ? '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤—ã–∫–ª' : '–ú–∏–∫—Ä–æ—Ñ–æ–Ω –≤–∫–ª'; }
    function toggleCam(){ if (!localStream) return; const vts = localStream.getVideoTracks(); if (!vts.length) return; vts.forEach(t=>t.enabled = !t.enabled); el('btnToggleCam').textContent = vts[0].enabled ? '–ö–∞–º–µ—Ä–∞ –≤—ã–∫–ª' : '–ö–∞–º–µ—Ä–∞ –≤–∫–ª'; }

    // =================== Events wiring ===================
    document.getElementById('createBtn').addEventListener('click', async ()=>{
      try{ await populateDevices(); await getLocalMedia(); createRoom(); }catch(e){ alert('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–µ–¥–∏–∞: '+e.message); }
    });
    document.getElementById('joinBtn').addEventListener('click', async ()=>{
      try{ await populateDevices(); await getLocalMedia(); joinRoom(); }catch(e){ alert('–û—à–∏–±–∫–∞ –¥–æ—Å—Ç—É–ø–∞ –∫ –º–µ–¥–∏–∞: '+e.message); }
    });

    el('sendBtn').addEventListener('click', ()=>{
      const txt = el('chatInput').value.trim(); if(!txt) return; socket.emit('chat-message',{ roomId: joinedRoom, message: { text: txt, from: profile.name } }); el('chatInput').value='';
    });

    el('copyLink').addEventListener('click', ()=>{ const url = el('inviteBox').textContent; navigator.clipboard.writeText(url).then(()=>alert('–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞')) });
    el('btnToggleMic').addEventListener('click', toggleMic);
    el('btnToggleCam').addEventListener('click', toggleCam);
    el('videoSelect').addEventListener('change', switchDevices);
    el('audioSelect').addEventListener('change', switchDevices);

    (function initFromURL(){ const params = new URLSearchParams(location.search); const r = params.get('room'); if (r) el('roomId').value = r; })();

    window.addEventListener('beforeunload', ()=>{ try{ if (socket) socket.emit('leave-room',{ roomId: joinedRoom }); }catch(e){} });

    navigator.mediaDevices && navigator.mediaDevices.enumerateDevices().then(populateDevices).catch(()=>{});
  </script>

  <!--
    –ò–Ω—Å—Ç—Ä—É–∫—Ü–∏—è:
    1) –ü–æ–¥–Ω–∏–º–∏—Ç–µ signalling server (Node+Express+Socket.IO) –Ω–∞ http://localhost:4000. API –¥–æ–ª–∂–µ–Ω –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞—Ç—å —Å–æ–±—ã—Ç–∏—è:
       - 'create-room' ({roomId, profile}, cb)
       - 'join-room' ({roomId, profile}, cb) -> cb({ok:true, participants: [...]})
       - 'signal' ({to, data}) ‚Äî —Ä–µ—Ç—Ä–∞–Ω—Å–ª–∏—Ä—É–µ—Ç—Å—è –∫ —Å–æ–∫–µ—Ç—É —Å id=to
       - 'participants-update' ‚Äî —Å–µ—Ä–≤–µ—Ä —ç–º–∏—Ç–∏—Ç –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è—Ö
       - 'chat-message' ‚Äî —Å–µ—Ä–≤–µ—Ä —Ä–µ—Ç—Ä–∞–Ω—Å–ª–∏—Ä—É–µ—Ç –≤ –∫–æ–º–Ω–∞—Ç–µ
       - 'status-update' ‚Äî —Å–µ—Ä–≤–µ—Ä —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç –∏ —Ä–µ—Ç—Ä–∞–Ω—Å–ª–∏—Ä—É–µ—Ç speaking –∏ –¥—Ä. —Å—Ç–∞—Ç—É—Å—ã
    2) –ü—Ä–∏–º–µ—Ä –ø—Ä–æ—Å—Ç–æ–≥–æ —Å–∏–≥–Ω–∞–ª—å–Ω–æ–≥–æ —Å–µ—Ä–≤–µ—Ä–∞ ‚Äî –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å server/server.js –∏–∑ –∞—Ä—Ö–∏–≤–∞. –î–ª—è –ª–æ–∫–∞–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–∞–ø—É—Å—Ç–∏—Ç–µ:
       cd server && npm install && npm start
    3) –û–∫–æ–Ω—á–∞—Ç–µ–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞: mesh WebRTC –ø–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –Ω–µ–±–æ–ª—å—à–∏—Ö –≥—Ä—É–ø–ø (<=6). –î–ª—è –±–æ–ª—å—à–∏—Ö –≥—Ä—É–ø–ø –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ SFU.
  -->
</body>
</html>
